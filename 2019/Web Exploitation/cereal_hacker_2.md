# CEREAL-HACKER-2
### Thể loại: Web Exploitation.
### Thử thách: 
Đây là part 2 của cereal hacker 1. Nhưng mục tiêu của chúng ta lần này không phải là đăng nhập với tư cách admin nữa mà phải lấy được mật khẩu của thằng admin:))

https://2019shell1.picoctf.com/problem/62195/
### Gợi ý: không có
### Kiến thức nền:
 - Local file inclusion.
 - PHP Wrappers and Protocols.
 - SQL injection.
 - SSH Protocol.
### Giải quyết vấn đề:
1/ Initial reconnaissance:
Nhìn giao diện của trang web này không khác gì của cái trang đầu. Vậy thì hãy cùng đi sâu vào bên trong để xem nó có khác biệt gì không nào. Lặp lại bước mấu chốt để tìm ra flag trong bài cereal hacker 1 (chi tiết xem các phần 3 của write-up [cereal hacker 1](https://github.com/antoinenguyen-09/picoCTF_write-up/blob/master/2019/Web%20Exploitation/cereal_hacker_1.md),) chúng ta thu được kết quả như sau:

![image](https://user-images.githubusercontent.com/61876488/92147452-5f76d980-ee45-11ea-9cc0-19b725ade716.png)

Đúng như mình dự đoán, lần này khi gửi request lên server thì browser không để lộ HTTP Cookie ra nữa. Giở lại cái list kiến thức nền của write-up [cereal hacker 1](https://github.com/antoinenguyen-09/picoCTF_write-up/blob/master/2019/Web%20Exploitation/cereal_hacker_1.md) :

![image](https://user-images.githubusercontent.com/61876488/92149057-a796fb80-ee47-11ea-8be5-8860e876e493.png)

Theo như những gì mình test nãy giờ thì ba lỗ hổng phía dưới đã được trang web này fix lại rồi. Chỉ còn duy nhất cái phía trên: Local File Inclusion. "Hiện tượng lạ" mà mình mắt thấy chứ hông có nằm chiêm bao này càng khẳng định khả năng trên 99.9% sẽ xảy ra:

![image](https://user-images.githubusercontent.com/61876488/92150380-88996900-ee49-11ea-8e2d-8ec14ba98074.png)

Cùng một thay đổi nhỏ trên URL của 2 trang web này là `file=antoine` nhưng lại trả về 2 kết quả khác nhau. Dòng "Unable to locate ....php" hiện ra trên page là 1 message PHP 404 Not Found được trả về từ server.  Không những vậy, khi mình truyền vào `file=antoine.php`, ta có output như sau:

![image](https://user-images.githubusercontent.com/61876488/92484639-260ee700-f214-11ea-9f01-2f5c8ccf838b.png)

Rõ ràng browser đã cố tình chèn vào cuối value của parameter file mà mình nhập vào một extension ".php". Do đó, tất cả các "file" mà browser trả về đều phải có gán extension ".php" khi được lưu trữ trong server thì mới hiển thị nội dung của nó trên browser, nếu không nó sẽ trả lại dòng báo lỗi như hình trên.
Như vậy mục tiêu chúng ta nhắm tới tiếp theo đây chính là parameter "file" trên URL.

2/ Path Traversal:

Trước tiên, chúng ta sẽ thử phương án [path traversal](https://owasp.org/www-community/attacks/Path_Traversal) (hay còn gọi là dot-dot-slash). Cú pháp để nhập vào là một dãy n các dấu "../" nối tiếp nhau + với tên file hoặc folder (nằm trong hoặc nằm ngoài thư mục gốc (root) của web) mà chúng ta muốn tìm trong hệ thống file của web server. Hệ thống file của web server nó cũng giống như của một cái máy tính bình thường mà chúng ta sử dụng vậy, có tính phân cấp (hierarchical) thể hiện thông qua path của một file (thương thấy trên File Explorer của Windows):
 ![image](https://user-images.githubusercontent.com/61876488/92197551-48170b00-ee9c-11ea-9b02-2ff79a644bff.png)
 
Tuy nhiên ở đây có khác một tí đó là chúng ta (client) không thể biết phía bên kia server có chứa những file gì, tên là gì, path của nó như thế nào, cho nên việc duy nhất ta có thể làm bây giờ là "mò kim đáy bể". Dấu "../" sẽ giúp việc "mò kim đáy bể" của chúng ta trở nên possible một chút, nó sẽ lấp vào chỗ trống của các folder trong mà chúng ta không biết tên có trong path của file cần tìm. 

![image](https://user-images.githubusercontent.com/61876488/92196648-e2c21a80-ee99-11ea-8c31-b6e3070b3dc0.png)

Đây là một kiểu path traversal thường gặp nhất. Mình đang cố truy cập vào file [/etc/passwd](https://manthang.wordpress.com/2010/11/27/tim-hieu-cau-truc-cua-file-etc-password/) vì có khả năng server được run bởi một hệ điều hành Unix-Linux based và trong các hệ điều hành loại này thì file "passwd" là nơi chứa user database (vì đề bài yêu cầu lấy pass của admin). Nhưng output nó chỉ là một màn hình trắng tinh:v Lý do là bởi directory đó không tồn tại trong server. Sau một hồi tăng giảm số lượng "../" cuối cùng mình đã ra được:

![image](https://user-images.githubusercontent.com/61876488/92489177-ad128e00-f219-11ea-98a1-a167d2228320.png)

File "passwd" trong server không được gán extension ".php". Phương án này như vậ vậy không còn khả thi nữa rồi.
3/ PHP Wrappers and Protocols:
Chợt nhớ ra lúc làm bài [cereal hacker 1](https://github.com/antoinenguyen-09/picoCTF_write-up/blob/master/2019/Web%20Exploitation/cereal_hacker_1.md) mình có lần parameter file giá trị "admin". Không biết nếu làm như vậy với URL của trang web này thì sẽ như nào nhỉ? Test thử xem nào:

![image](https://user-images.githubusercontent.com/61876488/92496740-b8b68280-f222-11ea-8c66-ffabc80d78da.png)

Content giống y như bên [cereal hacker 1](https://github.com/antoinenguyen-09/picoCTF_write-up/blob/master/2019/Web%20Exploitation/cereal_hacker_1.md). Có cách nào để xem được đoạn code php đã tạo ra content này không nhỉ? Chúng ta có thể sử dụng các [PHP Wrapper](https://www.php.net/manual/en/wrappers.php). Đoạn code php mà chúng ta cần tìm nhiều khả năng nằm trong [I/O stream](https://viblo.asia/p/tim-hieu-ve-streams-trong-php-63vKjmaM52R) của file "admin", do đó  [Wrapper](https://www.cdxy.me/?p=752) mà mình dùng ở đây sẽ là `php://filter/resource=<tên stream cần filter, ở đây là "admin">`. Kết quả vẫn như lúc nãy không thay đổi gì. Thử chèn vào thêm một parameter "read", giá trị truyền vào parameter này là tên một built-in [stream filter](https://www.php.net/manual/en/filters.php) được support trong PHP. Trong PHP hỗ trợ 4 loại filter sau (các phiên bản PHP khác nhau có thể có nhiều hơn hoặc ít hơn 4 loại này):

![image](https://user-images.githubusercontent.com/61876488/92552345-a2dca800-f28a-11ea-9715-b0a64b8b35a1.png)

[String Filter](https://www.php.net/manual/en/filters.string.php) thường chỉ dùng để chèn vào một parameter "write" chứ không phải "read". [Encryption Filter](https://www.php.net/manual/en/filters.encryption.php) cũng không nên được dùng vì nó đã không còn được sử dụng từ PHP bản 7.1.0. Sử dụng [Compression Filters](https://www.php.net/manual/en/filters.compression.php) lại cho output một dãy tiếng "Ả Rập" này (thường thấy ở trong các file nén như rar hay zip). Lý do tại sao lại như vậy thì các bạn có thể đọc tại [đây](https://www.php.net/manual/en/filters.compression.php) (chú ý phần định nghĩa với phần Note):
  
  ![image](https://user-images.githubusercontent.com/61876488/92553688-d0772080-f28d-11ea-9bb9-14337651318b.png)
  
Mới nhìn sơ qua thôi đã thấy nhác decrypt rồi:v Bây giờ chỉ còn lại [Conversion Filters](https://www.php.net/manual/en/filters.convert.php).  Chúng ta có thể sử dụng filter "convert.base64-encode" để convert code php của trang web này về dạng base64:

![image](https://user-images.githubusercontent.com/61876488/92583475-8eb19e80-f2bc-11ea-84ab-a53b2b9aa434.png)

Tuyệt cmn vời!!!!! Bây giờ chúng ta chỉ việc [decode](https://www.base64decode.org/) cái đống raw code này như đã làm ở bài [cereal hacker 1](https://github.com/antoinenguyen-09/picoCTF_write-up/blob/master/2019/Web%20Exploitation/cereal_hacker_1.md) là xong. Kết quả y như mình đoán:

  ```php
  <?php
require_once('cookie.php');

if(isset($perm) && $perm->is_admin()){
?>
  ```
 Ở đây mình chỉ trích ra 1 đoạn nhỏ nhưng lại là đoạn quan trọng nhất trong phần code đã được decrypt. Lệnh require_once() trong PHP được sử dụng để chèn một file php
trong một hoặc nhiều file php khác, ở đây chúng ta chèn nội dung file "cookie.php" vào trong file "admin.php". File "cookie.php" chắc chắn được lưu ở trong server, bởi vì nếu nó không tồn tại thì chương trình sẽ bị dừng lại và cho ra output là một màn hình trắng tinh.
Lặp lại các bước như trên đối với file "cookie":

![image](https://user-images.githubusercontent.com/61876488/92586141-12b95580-f2c0-11ea-8906-d9835df6e8db.png)

Ta thu được file php có nội dung như sau:

 ```php
 <?php

require_once('../sql_connect.php');

// I got tired of my php sessions expiring, so I just put all my useful information in a serialized cookie
class permissions
{
	public $username;
	public $password;
	
	function __construct($u, $p){
		$this->username = $u;
		$this->password = $p;
	}

	function is_admin(){
		global $sql_conn;
		if($sql_conn->connect_errno){
			die('Could not connect');
		}
		//$q = 'SELECT admin FROM pico_ch2.users WHERE username = \''.$this->username.'\' AND (password = \''.$this->password.'\');';
		
		if (!($prepared = $sql_conn->prepare("SELECT admin FROM pico_ch2.users WHERE username = ? AND password = ?;"))) {
		    die("SQL error");
		}

		$prepared->bind_param('ss', $this->username, $this->password);
	
		if (!$prepared->execute()) {
		    die("SQL error");
		}
		
		if (!($result = $prepared->get_result())) {
		    die("SQL error");
		}

		$r = $result->fetch_all();
		if($result->num_rows !== 1){
			$is_admin_val = 0;
		}
		else{
			$is_admin_val = (int)$r[0][0];
		}
		
		$sql_conn->close();
		return $is_admin_val;
	}
}

/* legacy login */
class siteuser
{
	public $username;
	public $password;
	
	function __construct($u, $p){
		$this->username = $u;
		$this->password = $p;
	}

	function is_admin(){
		global $sql_conn;
		if($sql_conn->connect_errno){
			die('Could not connect');
		}
		$q = 'SELECT admin FROM pico_ch2.users WHERE admin = 1 AND username = \''.$this->username.'\' AND (password = \''.$this->password.'\');';
		
		$result = $sql_conn->query($q);
		if($result->num_rows != 1){
			$is_user_val = 0;
		}
		else{
			$is_user_val = 1;
		}
		
		$sql_conn->close();
		return $is_user_val;
	}
}


if(isset($_COOKIE['user_info'])){
	try{
		$perm = unserialize(base64_decode(urldecode($_COOKIE['user_info'])));
	}
	catch(Exception $except){
		die('Deserialization error.');
	}
}

?>

 ```
Tiếp tục xuất hiện một đoạn code khả nghi ở ngay phía trên top:
```php
 <?php
require_once('../sql_connect.php');
```
File "../sql_connect.php" này phải chăng sẽ cho chúng ta các cách thức và thông tin để đăng nhập vào database của server? Tiếp tục làm như trên đối với file "../sql_connect.php" ta thu được:

```php
<?php
$sql_server = 'localhost';
$sql_user = 'mysql';
$sql_pass = 'this1sAR@nd0mP@s5w0rD#%';
$sql_conn = new mysqli($sql_server, $sql_user, $sql_pass);
$sql_conn_login = new mysqli($sql_server, $sql_user, $sql_pass);
?>
```
Khà khà! Đúng như vậy. Đoạn code trên cho ta đầy đủ chìa khóa để tìm ra flag, từ sql_user cho tới sql_pass. Nhưng user "mysql" này lại nằm trong server "localhost", chính là nằm trên server của trang web này, có domain name là `2019shell1.picoctf.com`. Đây cũng chính là domain name của shell server của picoCTF2019.
![image](https://user-images.githubusercontent.com/61876488/92588333-097db800-f2c3-11ea-85bc-f033501bb1e9.png)

Chúng ta có thể kết nối đến shell server này thông qua [giao thức ssh](https://www.hostinger.vn/huong-dan/ssh-la-gi-va-cach-su-dung-ssh-cho-nguoi-moi-bat-dau/).  

![image](https://user-images.githubusercontent.com/61876488/92592525-e73b6880-f2c9-11ea-86a5-7170648748ec.png)

Platform password chính là pass dùng để login vào tài khoản picoCTF2019 của bạn. 

![image](https://user-images.githubusercontent.com/61876488/92592947-87918d00-f2ca-11ea-965d-bc43d7db59f8.png)

Bây giờ thì chúng ta có thể dễ dàng làm bất kì điều gì tùy thích trên cái server này y như làm trên máy của chúng ta vậy ([remote control](https://graphicartsmag.com/articles/2003/11/remote-control-with-ssh/)). Mình sẽ truy cập vào database của shell server này dựa theo những thông tin đã có ở phía trên. Dùng lệnh:

    
    mysql -u mysql -p
Sau khi nhập pass thành công (sql_pass), chúng ta sẽ check từng databases một. Ưu tiên hai database pico_ch1 và pico_ch2 trước (vì cái tên nó triggered quá thôi chứ ko có gì cả:v). 

![image](https://user-images.githubusercontent.com/61876488/92598790-7f8a1b00-f2d3-11ea-8989-444d5b6e4926.png)
 
Password của admin mà chúng ta cần tìm phải có dạng "picoCTF{<something..>}" . Như vậy cái này không hợp lệ. Check tiếp thằng pico_ch2 xem nào:

![image](https://user-images.githubusercontent.com/61876488/92599843-fb389780-f2d4-11ea-9e97-ce91ac293d50.png)

Bingo! Vậy là chúng ta đã tìm ra flag:>>>> FINISH!!!!
